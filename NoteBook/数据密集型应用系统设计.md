# 数据系统的基石

## 可靠性、可维护性、可拓展性

1. **数据密集型**和**计算密集型**的区别是什么？
   1. 数据密集型应用程序受制于**数据量**、**数据复杂性**、以及**数据的变更速度**；
   2. 计算密集型应用程序受制于**CPU速度**。
2. 有哪些衡量分布式系统好坏的指标？
   1. 可靠性： 系统在**困境（adversity）**（硬件故障、软件故障、人为错误）中仍可正常工作（正确完成功能，并能达到期望的性能水准）。
   2. 可拓展性： 系统在**困境（adversity）**（硬件故障、软件故障、人为错误）中仍可正常工作（正确完成功能，并能达到期望的性能水准）。
   3. 可维护性： 许多不同的人（工程师、运维）在不同的生命周期，都能高效地在系统上工作（使系统保持现有行为，并适应新的应用场景）。
3. 分布式系统有哪些常见的故障?
   1. 软件故障;
   2. 硬件故障;
   3. 人为故障;
4. 有哪些描述性能的指标?
   1. 算术平均数: 隐藏了有多少用户实际上经历了极端情况;
   2. **百分位点**很好的表现了这个情况。
5. 什么是水平扩展和垂直扩展？
   1. horizontal scaling: 将负载分不到多台小机器;
   2. vertical scaling: 转向更强大的机器。
   3. 但是高端机器可能非常昂贵， 所以非常密集的负载通常无法避免地需要横向扩展。
6. 什么是无状态服务和有状态服务？
   1. 无状态服务的服务端不会保存任何关于前一次请求的信息。

## 数据模型与查询语言
1. 什么是关系型数据模型，它的优缺点是什么？
   1. 用表格（关系）来表示和存储数据的数据模型。
   2. 主键： 每个表格通常有一个主键，用于唯一标识表中的每个记录。
   3. 外键： 表格之间可以通过外键建立关系，实现数据的关联性。
   4. 缺点：固定的模式、拓展性不高。 
2. 什么是 NoSQL 数据库，它的优缺点是什么？
   1. NoSQL（Not Only SQL）数据库是一类不依赖于传统的关系型数据库模型的数据库系统。这些数据库系统采用了不同的数据模型，包括**文档型**、**键值对型**、**列族型**和**图型**等，以满足不同类型和规模的数据存储需求。NoSQL数据库的出现是为了解决关系型数据库在某些方面的限制。
   2. 优点：
      1. 灵活的数据模型；
      2. 分布式架构；
      3. 无固定模式；
   3. 缺点：
      1. 分布式环境下一致性和事务的处理；
      2. 查询语言不同意。
3. 什么是文档数据库？它和关系型数据库有什么区别？
   1. 文档数据库是一种 NoSQL 数据库，其数据模型基于文档的表示形式，通常使用像 JSON 或 BSON 这样的格式。数据以文档为单位存储，每个文档可以包含不同结构的字段，允许嵌套和非规范化的数据。MongoDB 是一个常见的文档数据库例子。
   2. 特点：
      1. **文档模型：** 数据以文档的形式存储，文档是键值对的集合，可以包含嵌套的文档和数组。

      2. **水平扩展：** 支持水平扩展，能够在多个节点上分布数据。

   3. 文档数据库与关系型数据库的区别：

      1. **数据模型：**
         - 关系型数据库使用**表格**的结构，其中每行是一个记录，每列是一个属性。数据需要预定义表结构。
         - 文档数据库使用**文档**的结构，每个文档是一个自包含的单元，不需要预定义的模式，可以包含不同结构的字段。

      2. **数据一致性和事务：**
         - 关系型数据库通常提供强一致性和事务支持，确保数据的完整性。
         - 文档数据库在一致性和事务方面可能相对较弱，特别是在分布式环境中。

      3. **应用场景：**
         - 关系型数据库适用于需要强调事务处理和数据一致性的应用，如金融系统、订单处理等。
         - 文档数据库适用于半结构化和非结构化数据的场景，如内容管理系统、博客平台、实时协作工具等。

4. 什么是图数据库？它适用于哪些场景？
   1. 图数据库是一种特殊类型的数据库，专门设计用于存储和处理图形数据结构。图数据库的数据模型基于图的概念，其中包含节点（表示实体）和边（表示节点之间的关系）。图数据库通过这些节点和边的连接关系来表示复杂的关联性数据。
   2. 图数据库的特点：

      1. **节点：** 表示实体的基本单元，可以包含属性描述实体的特征。

      2. **边：** 表示节点之间的关系，可以包含属性描述关系的特征。

      3. **灵活的关系模型：** 图数据库能够轻松表示实体之间复杂的关系，适用于多对多关系的场景。

      4. **高效的遍历能力：** 图数据库在处理需要深度遍历关系的查询时具有优势，例如社交网络中的朋友关系。

   3. 图数据库适用的场景：

      1. **社交网络：** 用于存储和查询用户之间的关系，以及社交网络中的朋友、关注等连接。

      2. **推荐系统：** 用于分析用户与商品之间的关系，实现个性化的推荐算法。

      3. **网络分析：** 用于分析网络拓扑结构、路径规划等，如路网图。

      4. **知识图谱：** 用于构建和查询知识图谱，表示实体之间的语义关系。

      5. **身份和访问管理：** 用于表示用户和资源之间的权限关系，支持复杂的授权模型。

      6. **生物信息学：** 用于存储基因、蛋白质等生物实体及其相互作用关系。

   4. 优点：

      1. **处理复杂关系：** 图数据库在处理实体之间复杂的关联性数据时非常高效。

      2. **灵活的数据模型：** 适应多对多关系，支持动态添加节点和边。

      3. **高效的遍历：** 在需要深度遍历关系的查询场景下具有较高性能。

   5. 缺点：

      1. **不适用于简单查询：** 在简单的数据检索场景下，图数据库可能过于复杂。

      2. **数据结构相对固定：** 虽然图数据库具有灵活的模型，但在某些方面相对于文档数据库和关系型数据库较为固定。

5. 什么是键值数据库？它适用于哪些场景？

   1. 键值数据库是一种基于简单键值对存储的 NoSQL 数据库。在键值对中，键是唯一的标识符，而值则是与该键相关联的数据。这种数据库模型简单直接，适用于需要快速存取和检索数据的场景。典型的键值数据库包括 Redis 和 Amazon DynamoDB。

   2. 键值数据库的特点：

      1. **简单的数据模型：** 数据以键值对的形式存储，没有复杂的结构，适合存储简单的数据。

      2. **快速的读写操作：** 键值数据库通常提供快速的读写操作，适用于需要高性能的场景。

      3. **高度可扩展：** 多数键值数据库支持水平扩展，能够在多个节点上分布数据。

      4. **灵活的存储：** 可以存储各种类型的数据，如字符串、整数、二进制数据等。

   3. 键值数据库适用的场景：

      1. **缓存系统：** 用于存储经常访问的数据，提高访问速度。

      2. **会话存储：** 适合存储用户会话信息，如用户登录状态。

      3. **计数器应用：** 用于实现简单的计数器功能，如网站访问次数统计。

      4. **配置管理：** 存储系统配置信息，支持快速的配置检索。

      5. **分布式锁：** 用于实现分布式系统中的锁机制。

      6. **实时分析：** 适用于存储实时分析数据，如日志信息。

   4. 优点：支持水平扩展，适应大规模数据存储需求。

   5. 缺点：

      1. **不适用于复杂查询：** 由于简单的键值模型，不适用于需要复杂查询和关联操作的场景。

      2. **有限的数据处理能力：** 不如文档型数据库或关系型数据库支持复杂的数据处理。


## 存储与检索
1. 什么是索引？有哪些常见索引？
   1. 精心选择的索引加快了读查询的速度，但是每个索引都会拖慢写入速度。
   2. 常见索引: hash index、LSM、B树；
2. 机械硬盘和固态硬盘在性能上有什么区别？
   1. 机械硬盘：使用旋转的磁盘和机械臂进行数据存取；
   2. 固态硬盘：使用闪存存储；
3. OLAP和OLTP的区别是什么？
   1. 在高层次上，我们看到存储引擎分为两大类：优化 **事务处理（OLTP）** 或 **在线分析（OLAP）** 。
   2. OLTP面向用户，可能收到大量请求， 但对每个请求通常只需要查询一部分够用就行；
   3. OLAP: 数仓主要供专业分析人员使用, 查询量少, 但是单个查询开销高昂。

### 描述Bitcask的架构
1. Bitcask 的数据结构是什么？如何实现数据的快速读取和写入？
   1. hash表；
   2. 先根据key找到offset，再根据offset快速定位key在数据文件中的位置。
2. Bitcask 如何保证数据的一致性和可靠性？如何处理数据的冲突？
   1. 采用**追加写入**， 从而利用文件系统确保操作的原子性；
   2. 定期合并， 定期备份，从而确保可靠性；
   3. 数据冲突时采用**最后写入原则**，系统会采用最后写入的值，覆盖之前的值；
3. 如何进行 Bitcask 的数据备份和恢复？
   1. 数据备份：停止写入 -> 备份存储键值对的数据文件 -> 备份Hint文件(存储的是index)
   2. 数据恢复: 还原数据文件和Hint文件 -> 启动Bitcask服务 -> 恢复写入
4. Bitcask 的适用场景是什么？它和其他存储引擎的区别是什么？
   1. 读取和写入操作频繁;
   2. **追加**是他的特点;

### LSM（Log-Structured Merge Tree）：
   1. 写入时，将其添加到内存中的平衡树数据结构（例如，红黑树）。这个内存树有时被称为**内存表（memtable）**。
   2. 当**内存表**大于某个阈值（通常为几兆字节）时，将其作为SSTable文件写入磁盘。这可以高效地完成，因为树已经维护了按键排序的键值对。新的SSTable文件成为数据库的最新部分。当SSTable被写入磁盘时，写入可以继续到一个新的内存表实例。
   3. 为了提供读取请求，首先尝试在内存表中找到关键字，然后在最近的磁盘段中，然后在下一个较旧的段中找到该关键字。
   4. 有时会在后台运行合并和压缩过程以组合段文件并丢弃覆盖或删除的值。
   5. 如果数据库崩溃，则最近的写入（在内存表中，但尚未写入磁盘）将丢失。为了避免这个问题，我们可以在磁盘上保存一个单独的日志，每个写入都会立即被附加到磁盘上。该日志不是按排序顺序，但这并不重要，因为它的唯一目的是在崩溃后恢复内存表。每当内存表写出到SSTable时，相应的日志都可以被丢弃。
   1. 什么是 LSM 树？
   2. LSM 树和 B 树有什么区别？
   3. LSM 树如何解决数据冲突问题？
   4. LSM 树的优点是什么？
   5. LSM 树的缺点是什么？
   6. LSM 树的读取性能如何？
   7. LSM 树的写入性能如何？
   8. LSM 树如何解决内存和磁盘之间的数据不一致问题？
   9. LSM 树如何解决内存和磁盘之间的数据不一致问题？
   10. LSM 树的数据合并过程是什么？
   11. LSM 树的应用场景是什么？
   ### B树
   1. 什么是 B 树？
   2. B 树和二叉搜索树的区别是什么？
   3. B 树的搜索操作如何实现？
   4. B 树的插入操作如何实现？
   5. B 树的删除操作如何实现？
   6. B 树的时间复杂度是多少？




## 编码与演化
1. 什么是 Protocol Buffers？  
   Protocol Buffers，简称为 Protobuf，是由Google开发的一种轻量级、高效的数据交换格式。它可以用于结构化数据的序列化，可用于通信协议、数据存储等领域。
2. Protocol Buffers 相比于 XML 和 JSON 有什么优点？  
   与 XML 和 JSON 相比，Protocol Buffers 在序列化和反序列化的速度、数据体积上都具有优势。
   1. protocol buffer 使用二进制格式进行数据序列化, json/xml使用的是文本格式;
   2. 跨平台和语言;
   3. 向后兼容性: 旧程序在读取到新字段时会跳过, 保证了向后兼容;
3. Protocol Buffers 的三个核心组件是什么？
   message, field, enum;
   ```protobuf
      syntax = "proto3";

      message Person {
         int32 id = 1;
         string name = 2;
         string email = 3;
      }
   ```
   在 proto3 中，所有的字段都被视为是可选的，而且不再使用 required 和 optional 关键字。