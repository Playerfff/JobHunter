# 数据系统的基石

## 可靠性、可维护性、可拓展性

1. **数据密集型**和**计算密集型**的区别是什么？
   1. 数据密集型应用程序受制于**数据量**、**数据复杂性**、以及**数据的变更速度**；
   2. 计算密集型应用程序受制于**CPU速度**。
2. 有哪些衡量分布式系统好坏的指标？
   1. 可靠性： 系统在**困境（adversity）**（硬件故障、软件故障、人为错误）中仍可正常工作（正确完成功能，并能达到期望的性能水准）。
   2. 可拓展性： 系统在**困境（adversity）**（硬件故障、软件故障、人为错误）中仍可正常工作（正确完成功能，并能达到期望的性能水准）。
   3. 可维护性： 许多不同的人（工程师、运维）在不同的生命周期，都能高效地在系统上工作（使系统保持现有行为，并适应新的应用场景）。
3. 分布式系统有哪些常见的故障?
   1. 软件故障;
   2. 硬件故障;
   3. 人为故障;
4. 有哪些描述性能的指标?
   1. 算术平均数: 隐藏了有多少用户实际上经历了极端情况;
   2. **百分位点**很好的表现了这个情况。
5. 什么是水平扩展和垂直扩展？
   1. horizontal scaling: 将负载分不到多台小机器;
   2. vertical scaling: 转向更强大的机器。
   3. 但是高端机器可能非常昂贵， 所以非常密集的负载通常无法避免地需要横向扩展。
6. 什么是无状态服务和有状态服务？
   1. 无状态服务的服务端不会保存任何关于前一次请求的信息。

## 数据模型与查询语言

1. 什么是关系型数据模型，它的优缺点是什么？
   1. 用表格（关系）来表示和存储数据的数据模型。
   2. 主键： 每个表格通常有一个主键，用于唯一标识表中的每个记录。
   3. 外键： 表格之间可以通过外键建立关系，实现数据的关联性。
   4. 缺点：固定的模式、拓展性不高。
2. 什么是 NoSQL 数据库，它的优缺点是什么？
   1. NoSQL（Not Only SQL）数据库是一类不依赖于传统的关系型数据库模型的数据库系统。这些数据库系统采用了不同的数据模型，包括**文档型**、**键值对型**、**列族型**和**图型**等，以满足不同类型和规模的数据存储需求。NoSQL数据库的出现是为了解决关系型数据库在某些方面的限制。
   2. 优点：
      1. 灵活的数据模型；
      2. 分布式架构；
      3. 无固定模式；
   3. 缺点：
      1. 分布式环境下一致性和事务的处理；
      2. 查询语言不同意。
3. 什么是文档数据库？它和关系型数据库有什么区别？
   1. 文档数据库是一种 NoSQL 数据库，其数据模型基于文档的表示形式，通常使用像 JSON 或 BSON 这样的格式。数据以文档为单位存储，每个文档可以包含不同结构的字段，允许嵌套和非规范化的数据。MongoDB 是一个常见的文档数据库例子。
   2. 特点：
      1. **文档模型：** 数据以文档的形式存储，文档是键值对的集合，可以包含嵌套的文档和数组。

      2. **水平扩展：** 支持水平扩展，能够在多个节点上分布数据。

   3. 文档数据库与关系型数据库的区别：

      1. **数据模型：**
         - 关系型数据库使用**表格**的结构，其中每行是一个记录，每列是一个属性。数据需要预定义表结构。
         - 文档数据库使用**文档**的结构，每个文档是一个自包含的单元，不需要预定义的模式，可以包含不同结构的字段。

      2. **数据一致性和事务：**
         - 关系型数据库通常提供强一致性和事务支持，确保数据的完整性。
         - 文档数据库在一致性和事务方面可能相对较弱，特别是在分布式环境中。

      3. **应用场景：**
         - 关系型数据库适用于需要强调事务处理和数据一致性的应用，如金融系统、订单处理等。
         - 文档数据库适用于半结构化和非结构化数据的场景，如内容管理系统、博客平台、实时协作工具等。

4. 什么是图数据库？它适用于哪些场景？
   1. 图数据库是一种特殊类型的数据库，专门设计用于存储和处理图形数据结构。图数据库的数据模型基于图的概念，其中包含节点（表示实体）和边（表示节点之间的关系）。图数据库通过这些节点和边的连接关系来表示复杂的关联性数据。
   2. 图数据库的特点：

      1. **节点：** 表示实体的基本单元，可以包含属性描述实体的特征。

      2. **边：** 表示节点之间的关系，可以包含属性描述关系的特征。

      3. **灵活的关系模型：** 图数据库能够轻松表示实体之间复杂的关系，适用于多对多关系的场景。

      4. **高效的遍历能力：** 图数据库在处理需要深度遍历关系的查询时具有优势，例如社交网络中的朋友关系。

   3. 图数据库适用的场景：

      1. **社交网络：** 用于存储和查询用户之间的关系，以及社交网络中的朋友、关注等连接。

      2. **推荐系统：** 用于分析用户与商品之间的关系，实现个性化的推荐算法。

      3. **网络分析：** 用于分析网络拓扑结构、路径规划等，如路网图。

      4. **知识图谱：** 用于构建和查询知识图谱，表示实体之间的语义关系。

      5. **身份和访问管理：** 用于表示用户和资源之间的权限关系，支持复杂的授权模型。

      6. **生物信息学：** 用于存储基因、蛋白质等生物实体及其相互作用关系。

   4. 优点：

      1. **处理复杂关系：** 图数据库在处理实体之间复杂的关联性数据时非常高效。

      2. **灵活的数据模型：** 适应多对多关系，支持动态添加节点和边。

      3. **高效的遍历：** 在需要深度遍历关系的查询场景下具有较高性能。

   5. 缺点：

      1. **不适用于简单查询：** 在简单的数据检索场景下，图数据库可能过于复杂。

      2. **数据结构相对固定：** 虽然图数据库具有灵活的模型，但在某些方面相对于文档数据库和关系型数据库较为固定。

5. 什么是键值数据库？它适用于哪些场景？

   1. 键值数据库是一种基于简单键值对存储的 NoSQL 数据库。在键值对中，键是唯一的标识符，而值则是与该键相关联的数据。这种数据库模型简单直接，适用于需要快速存取和检索数据的场景。典型的键值数据库包括 Redis 和 Amazon DynamoDB。

   2. 键值数据库的特点：

      1. **简单的数据模型：** 数据以键值对的形式存储，没有复杂的结构，适合存储简单的数据。

      2. **快速的读写操作：** 键值数据库通常提供快速的读写操作，适用于需要高性能的场景。

      3. **高度可扩展：** 多数键值数据库支持水平扩展，能够在多个节点上分布数据。

      4. **灵活的存储：** 可以存储各种类型的数据，如字符串、整数、二进制数据等。

   3. 键值数据库适用的场景：

      1. **缓存系统：** 用于存储经常访问的数据，提高访问速度。

      2. **会话存储：** 适合存储用户会话信息，如用户登录状态。

      3. **计数器应用：** 用于实现简单的计数器功能，如网站访问次数统计。

      4. **配置管理：** 存储系统配置信息，支持快速的配置检索。

      5. **分布式锁：** 用于实现分布式系统中的锁机制。

      6. **实时分析：** 适用于存储实时分析数据，如日志信息。

   4. 优点：支持水平扩展，适应大规模数据存储需求。

   5. 缺点：

      1. **不适用于复杂查询：** 由于简单的键值模型，不适用于需要复杂查询和关联操作的场景。

      2. **有限的数据处理能力：** 不如文档型数据库或关系型数据库支持复杂的数据处理。

## 存储与检索

1. 什么是索引？有哪些常见索引？
   1. 精心选择的索引加快了读查询的速度，但是每个索引都会拖慢写入速度。
   2. 常见索引: hash index、LSM、B树；
2. 机械硬盘和固态硬盘在性能上有什么区别？
   1. 机械硬盘：使用旋转的磁盘和机械臂进行数据存取；
   2. 固态硬盘：使用闪存存储；
3. OLAP和OLTP的区别是什么？
   1. 在高层次上，我们看到存储引擎分为两大类：优化 **事务处理（OLTP）** 或 **在线分析（OLAP）** 。
   2. OLTP面向用户，可能收到大量请求， 但对每个请求通常只需要查询一部分够用就行；
   3. OLAP: 数仓主要供专业分析人员使用, 查询量少, 但是单个查询开销高昂。

### 描述Bitcask的架构

1. Bitcask 的数据结构是什么？如何实现数据的快速读取和写入？
   1. hash表；
   2. 先根据key找到offset，再根据offset快速定位key在数据文件中的位置。
2. Bitcask 如何保证数据的一致性和可靠性？如何处理数据的冲突？
   1. 采用**追加写入**， 从而利用文件系统确保操作的原子性；
   2. 定期合并， 定期备份，从而确保可靠性；
   3. 数据冲突时采用**最后写入原则**，系统会采用最后写入的值，覆盖之前的值；
3. 如何进行 Bitcask 的数据备份和恢复？
   1. 数据备份：停止写入 -> 备份存储键值对的数据文件 -> 备份Hint文件(存储的是index)
   2. 数据恢复: 还原数据文件和Hint文件 -> 启动Bitcask服务 -> 恢复写入
4. Bitcask 的适用场景是什么？它和其他存储引擎的区别是什么？
   1. 读取和写入操作频繁;
   2. **追加**是他的特点;

### LSM（Log-Structured Merge Tree）

1. 什么是 LSM 树？
   1. 写入时，将其添加到内存中的平衡树数据结构（例如，红黑树）。这个内存树有时被称为**内存表（memtable）**。
   2. 当**内存表**大于某个阈值（通常为几兆字节）时，将其作为SSTable文件写入磁盘。这可以高效地完成，因为树已经维护了按键排序的键值对。新的SSTable文件成为数据库的最新部分。当SSTable被写入磁盘时，写入可以继续到一个新的内存表实例。
   3. 为了提供读取请求，首先尝试在内存表中找到关键字，然后在最近的磁盘段中，然后在下一个较旧的段中找到该关键字。
   4. 有时会在后台运行合并和压缩过程以组合段文件并丢弃覆盖或删除的值。
   5. 如果数据库崩溃，则最近的写入（在内存表中，但尚未写入磁盘）将丢失。为了避免这个问题，我们可以在磁盘上保存一个单独的日志，每个写入都会立即被附加到磁盘上。该日志不是按排序顺序，但这并不重要，因为它的唯一目的是在崩溃后恢复内存表。每当内存表写出到SSTable时，相应的日志都可以被丢弃。
3. LSM 树如何解决数据冲突问题？  
最后写入策略
4. LSM 树的优点是什么？  
高性能写入, 频繁写入场景
5. LSM 树的缺点是什么？
读取性能低

### B树

1. 什么是 B 树？

   B 树（B-Tree）是一种自平衡的搜索树数据结构，常被用于实现关系型数据库的索引结构。B 树具有以下主要特征：

   1. 平衡树结构： B 树是一种自平衡的树结构，保持了从根节点到叶子节点的深度相等，使得每个查询操作的时间复杂度为 O(log n)。
   2. 分支因子： B 树的每个节点可以拥有多个子节点，而不仅仅是两个。这个多个子节点的数量称为分支因子（branching factor），通常用符号 t 表示。B 树的节点上至多有 2t-1 个关键字。
   3. 有序性： 每个节点中的关键字都是有序排列的，使得对整个树进行范围查询非常高效。
   4. 高度平衡： B 树的自平衡性质确保了整个树的高度是相对平衡的，这有助于维持查询的高效性。
   5. 适用于外存储： 由于 B 树的设计考虑了磁盘读写的效率，它通常被广泛用于实现数据库索引，特别是在关系型数据库中。

3. B 树的基本操作:
   1. 搜索操作：  
   B 树的搜索操作类似于二叉搜索树，但有一些差异：

   - 从根节点开始： 从树的根节点开始，比较要搜索的关键字与节点中关键字的大小，根据比较结果确定向左还是向右子树移动。

   - 多分支： 由于 B 树节点可以包含多个关键字，搜索过程需要在节点中按序查找。

   - 递归： 如果在非叶子节点上找到了对应的关键字，递归地在相应的子树中继续搜索。如果在叶子节点上找到了对应的关键字，则搜索成功。

2. 插入操作：
   B 树的插入操作可能涉及到节点的分裂。

   - 从根节点开始搜索： 首先，从根节点开始搜索要插入的位置。

   - 找到插入位置： 如果找到了合适的叶子节点，将新的关键字插入到该节点中。如果插入后节点的关键字数量超过了规定的最大值，执行分裂操作。

   - 分裂操作： 将节点中的关键字一分为二，将中间值提升到父节点。这可能会导致父节点的关键字数量超过最大值，也需要进行分裂。如果父节点的分裂导致根节点的分裂，树的高度会增加。

3. 删除操作：
   B 树的删除操作可能涉及到节点的合并。

   - 从根节点开始搜索： 从根节点开始搜索要删除的关键字。

   - 找到删除位置： 如果找到了要删除的关键字，执行删除操作。如果删除导致节点中关键字的数量低于最小值，执行合并操作。

   - 合并操作： 将相邻的节点进行合并，同时将父节点中的相应关键字删除。这可能会导致父节点关键字数量低于最小值，需要递归执行合并操作。

   - 递归向上： 删除操作可能会导致递归向上，一直到根节点。如果根节点的关键字数量减为零，可以降低树的高度。
6. B 树的时间复杂度是多少？  
   分裂和合并操作确保了树的平衡，使得查询、插入和删除的时间复杂度保持在 **O(log n)** 的水平。

## 编码与演化

1. 什么是 Protocol Buffers？  
   Protocol Buffers，简称为 Protobuf，是由Google开发的一种轻量级、高效的数据交换格式。它可以用于结构化数据的序列化，可用于通信协议、数据存储等领域。
2. Protocol Buffers 相比于 XML 和 JSON 有什么优点？  
   与 XML 和 JSON 相比，Protocol Buffers 在序列化和反序列化的速度、数据体积上都具有优势。
   1. protocol buffer 使用二进制格式进行数据序列化, json/xml使用的是文本格式;
   2. 跨平台和语言;
   3. 向后兼容性: 旧程序在读取到新字段时会跳过, 保证了向后兼容;
3. Protocol Buffers 的三个核心组件是什么？
   message, field, enum;

   ```protobuf
      syntax = "proto3";

      message Person {
         int32 id = 1;
         string name = 2;
         string email = 3;
      }
   ```

   在 proto3 中，所有的字段都被视为是可选的，而且不再使用 required 和 optional 关键字。

# 分布式数据

## 复制
1. 同步复制和异步复制的区别？
2. 什么是分布式系统复制？
3. 什么是主从复制和多主复制？
4. 主从复制中的读写一致性如何保证？
5. 多主复制中的冲突如何处理？
6. 什么是基于日志的复制？如何实现基于日志的复制？
7. 什么是心跳机制？如何实现心跳机制？
8. 什么是数据一致性？如何保证数据一致性？
9. 什么是分布式一致性算法？常见的一致性算法有哪些？
10. 什么是 Raft 算法？与 Paxos 算法有何区别？
## 分区
1. 什么是分布式系统分区？
2.分布式系统分区有什么好处？
3. 什么是CAP理论？它如何解释分布式系统分区？
4. 什么是Quorum？它如何在分布式系统分区中发挥作用？
5. 什么是一致性哈希算法？它如何帮助解决分布式系统分区问题？
6. 什么是Gossip协议？它如何用于处理分布式系统分区问题？
7. 什么是分区容错？它如何与分布式系统分区相关？
## 事务
1. 什么是分布式系统事务？
2. 什么是ACID属性？在分布式系统事务中如何保证ACID属性？
3. 什么是BASE属性？在分布式系统事务中如何保证BASE属性？
4. 什么是两阶段提交协议？如何使用两阶段提交协议实现分布式系统事务？
5. 什么是三阶段提交协议？它相比两阶段提交协议有什么优势？
6. 什么是分布式锁？如何使用分布式锁来实现分布式系统事务？
## 分布式系统的麻烦
## 一致性与共识
1. 分布式系统有哪些一致性？他们之间的区别是？
2. 什么是分布式系统的两阶段提交协议（Two-Phase Commit Protocol）？
3. 两阶段提交协议的目的是什么？
4. 两阶段提交协议的优缺点是什么？
5. 什么情况下会发生两阶段提交协议的超时现象（Timeout）？
6. 什么是协调者（Coordinator）和参与者（Participant）？
7. 如何处理两个协调者之间的冲突？