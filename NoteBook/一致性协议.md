# 分布式基本理论
## CAP理论
1. 在一个分布式系统中，不可能同时满足**一致性（Consistency）**、**可用性（Availability）**、**分区容错性（Partition tolerance）**，最多只能同时实现两点。
    1. Consistency: 任一数据节点的数据都应该是一致的。
    2. Availability: 客户端访问数据的时候，能快速得到正常响应，不会存在超时或响应错误的情况。
    3. Partition tolerance: 出现网络分区问题的系统仍能对外提供服务。
2. 在CAP理论中, 分布式系统是必须考虑网络分区的, 由因为Consistency和Availability是矛盾的(要满足Consistency就必须在主从数据库同步数据时加锁, 要满足Availability就必须要求快速响应)。因此CAP可选的组合只有AP/CP.
3. [搞懂CAP和Base理论，看这一篇就够了](https://juejin.cn/post/7048478515766755336)
4. Consistency不是绝对的，而是相对的。在实际应用中，可以选择合适的一致性级别，例如强一致性、最终一致性等。
5. CAP理论和ACID理论区别: 
    1. CAP定理关注的是分布式系统在面临网络分区时的行为，强调在分区发生时需要选择一致性或可用性。
    2. 而ACID事务关注的是单个数据库事务的一致性，提供了一组保证事务正确执行的特性。


## BASE理论

> 在实际场景中，大部分公司会选择AP，保证可用性和分区容错性，舍弃一致性。但这里舍弃的是强一致性，即任意时间任意节点的数据都保持一致。经过一段时间后我们还是要保证数据是保持一致的，这就引入了Base理论.

Base理论是对AP的扩展, 其内容为: Basically Available（基本可用） 、Soft-state（软状态） 和 Eventually Consistent（最终一致性）.

该理论是对CAP理论中的AP的一个扩展，它的核心思想是：

> 当系统出现故障时,允许部分功能不可用，但要保证核心功能可用；允许数据在一段时间内不一致，但经过一段时间，数据最终要保证一致。

### 基本可用
基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性，比如响应时间或功能，但要保证系统基本可用。

比如，当电商系统出现故障时：

响应时间由原来的0.1s变成了1s，但也依然能响应。(延迟响应)  
商品图片加载错误，但下单依然正常。(服务降级)  
随机抛弃一些请求(过载保护)  
将数据保存到队列中慢慢消费(削峰填谷)

### 软状态
软状态指允许系统中的数据存在中间状态，这些状态不会影响系统的整体可用性，只允许系统的各个节点之间的数据同步出现延时。

在电商系统中的订单"支付中"、"退款中"等状态就是软状态。

### 最终一致性
最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。
最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。

实现的方式:
1. 写时复制;
2. 读时复制;
3. 异步复制.

比如，电商系统中的订单"支付中"、"退款中"等状态就是软状态，经过一段时间后，就会变成"支付成功"、"退款成功"的状态。



## 分布式2PC/3PC理论
[分布式系统的一致性协议之 2PC 和 3PC](https://matt33.com/2018/07/08/distribute-system-consistency-protocol/)

二阶段提交协议（Two-phase Commit，即2PC）


## 分布式一致性
[分布式系统一致性分类，你知道几种？](https://cloud.tencent.com/developer/article/1015442)

关于分布式系统的一致性模型有以下几种：

#### 强一致性
当更新操作完成之后，任何多个后续进程或者线程的访问都会返回最新的更新过的值，直到这个数据被其他数据更新为止。

但是这种实现对性能影响较大，因为这意味着，只要上次的操作没有处理完，就不能让用户读取数据。

#### 弱一致性
系统并不保证进程或者线程的访问都会返回最新更新过的值。系统在数据写入成功之后，不承诺立即可以读到最新写入的值，也不会具体的承诺多久之后可以读到。但会尽可能保证在某个时间级别（比如秒级别）之后，可以让数据达到一致性状态。

#### 最终一致性
最终一致性也是弱一致性的一种，它无法保证数据更新后，所有后续的访问都能看到最新数值，而是需要一个时间，在这个时间之后可以保证这一点，而在这个时间内，数据也许是不一致的，这个系统无法保证强一致性的时间片段被称为「不一致窗口」。不一致窗口的时间长短取决于很多因素，比如备份数据的个数、网络传输延迟速度、系统负载等。

## 复制状态机

复制状态机（Replicated State Machine，RSM）是一种分布式系统的设计模型，旨在确保在多个节点上复制的状态保持一致。该模型通过将状态和状态转换逻辑复制到不同的节点上，使系统能够在发生节点故障或网络分区的情况下保持一致性。

基本思想是将状态机的状态在不同节点上进行复制，并在每个节点上执行相同的命令序列，以确保在任何时间点，每个节点都处于相同的状态。这通常涉及到在节点之间进行通信，以达成一致的状态。

# 分布式一致性技术

分布式一致性，简单的说就是在一个或多个进程提议了一个值后，使系统中所有进程对这个值达成一致。

为了就某个值达成一致，每个进程都可以提出自己的提议，最终通过分布式一致性算法，所有正确运行的进程学习到相同的值。

## Paxos协议
基于消息传递且具有高度容错性的一致性算法。Paxos算法要解决的问题就是如何在可能发生几起宕机或网络异常的分布式系统中，快速且正确地在集群内部对某个数据的值达成一致，并且保证不论发生以上任何异常，都不会破坏整个系统的一致性。

### 目的
确保在分布式系统中的多个节点之间达成一致的共识.

### 三种身份
Paxos将系统中的角色分为提议者 (Proposer)，决策者 (Acceptor)，和最终决策学习者 (Learner):

- Proposer: 提出提案 (Proposal)。Proposal信息包括提案编号 (Proposal ID) 和提议的值 (Value)。
- Acceptor：参与决策，回应Proposers的提案。收到Proposal后可以接受提案，若Proposal获得多数Acceptors的接受，则称该Proposal被批准。
- Learner：不参与决策，从Proposers/Acceptors学习最新达成一致的提案（Value）。

### Majority
每次写都保证写入大于N/2个节点, 每次读保证从大于N/2个结点中读.

多数派的原则有助于保证系统在出现故障或分区的情况下仍能够维持一致性。例如，如果系统有 5 个节点，多数派就是 3 个节点。即使有 2 个节点发生故障或者无法通信，仍然有 3 个节点可以组成多数派，确保系统的一致性。这种设计使得 Paxos 协议在分布式环境中具有强大的容错性。 

### Basic Paxos phases
#### Phase 1a: Prepare
proposer提出一个提案, 编号为N, 此N大于这个proposer之前提出的提案编号. 请求acceptors的quorum接受.

#### Phase 1b: Promise
如果N大于此acceptor之前接受的任何提案编号则接受, 否则拒绝.

#### Phase 2a: Accept
如果达到了Majority, proposer会发出accept请求, 此请求包含提案编号N, 以及提案内容.

#### Phase 2b: Accepted
如果此acceptor在此期间没有收到任何编号大于N的提案, 则接受此提案内容, 否则忽略.

---
这个链接有助于理解: 25:00
[一致性算法（Paxos、Raft、ZAB）](https://www.bilibili.com/video/BV1TW411M7Fx/?spm_id_from=333.337.search-card.all.click&vd_source=4b193bf064c21c18a31ea22828cb0c56)

## Raft协议
multi paxos的简化版本, 划分成三个问题:
- Leader Election
- Log Replication
- Safety

定义三个角色:
- Leader
- Follower
- Candidate

[Raft原理动画解释](http://thesecretlivesofdata.com/raft/)

## ZAB协议
ZAB 协议的全称是 Zookeeper Atomic Broadcase，原子广播协议。[深入浅出 Zookeeper 中的 ZAB 协议](https://www.51cto.com/article/704705.html)

### Zookeeper各节点的角色
Leader：

- 负责处理客户端发送的读、写事务请求。这里的事务请求可以理解这个请求具有事务的 ACID 特性。
- 同步写事务请求给其他节点，且需要保证事务的顺序性。
- 状态为 LEADING。

Follower：

- 负责处理客户端发送的读请求
- 转发写事务请求给 Leader。
- 参与 Leader 的选举。
- 状态为 FOLLOWING。

Observer：

- 和 Follower 一样，唯一不同的是，不参与 Leader 的选举，且状态为 OBSERING。
- 可以用来线性扩展读的 QPS。

### 特点
 ZAB 协议的关键特性是原子广播，**确保所有节点按照相同的顺序接收并应用更新**。

## Gossip协议
[一致性算法-Gossip协议详解](https://cloud.tencent.com/developer/article/1662426)

Gossip 协议是一种**去中心化**的通信协议，用于在分布式系统中进行信息传播。其基本原理是通过节点之间相互交换信息，逐渐将信息传播到整个系统中，从而使系统中的所有节点最终具有相同的信息。

也正因为Gossip协议是去中心化的协议, 所以Gossip协议通常提供最终一致性, 而不是强一致性. 且无法实现通信的精准控制.

### 确保一致性

Gossip 协议通常提供最终一致性，而不是强一致性。最终一致性意味着在一段时间后，所有节点最终都会达到相同的状态，但在传播的过程中，节点之间的状态可能会存在一段时间的不一致。

在 Gossip 协议中，节点之间通过随机选择的方式进行信息传播，涉及到数据一致性的主要挑战在于节点间信息的交换和传播可能不是瞬时的。如果多个节点同时向其他节点发送数据，可能会导致一些节点在某个时刻看到的信息不同。

处理多个节点同时向其他节点发送数据的情况，通常需要考虑以下因素：

1. 冲突解决： 当多个节点同时向其他节点发送不同的数据时，可能会导致冲突。在 Gossip 协议中，这样的冲突通常是通过后续的消息传播来解决。节点在收到不同的数据后，通过与其他节点交换信息，逐渐达到一致状态。

2. 版本控制： 可以通过引入版本控制机制来帮助解决冲突。每个节点可以为自己的数据生成一个版本号，当节点收到其他节点的数据时，可以比较版本号，选择更新较新的数据。

3. 随机性： Gossip 协议中的随机性有助于缓解同时发送数据的冲突。由于节点的选择是随机的，节点在不同的时间点可能会选择不同的邻居进行信息传播，从而减少冲突的可能性。

4. 定期重复： Gossip 协议的信息传播是周期性的，节点会定期重复选择邻居节点进行信息交换。这样的重复过程有助于逐渐消解冲突，使系统最终趋于一致。

### 处理"慢节点"

在 Gossip 协议中，"慢"节点是指由于某种原因导致其响应速度较慢的节点。这可能是由于节点负载高、网络延迟大、硬件故障或其他原因。慢节点的存在可能对系统的性能产生一些影响，因此需要一些机制来处理。

**处理慢节点的方法：**

1. 超时机制： Gossip 协议通常包含超时机制，当一个节点选择另一个节点进行信息交换时，如果在预定的时间内没有收到响应，就会认为该节点是慢节点。超时机制可以帮助系统快速适应慢节点的情况，防止长时间的等待。

2. 重试策略： 当检测到一个节点变得慢时，系统可以采取一些重试策略，例如增加与该节点的交互频率，以尝试提高信息传播的成功率。

3. 自适应性： Gossip 协议通常是自适应的，系统可以根据节点的响应时间调整选择邻居节点的概率。响应时间较长的节点可能在下一轮选择邻居节点时被选择的概率降低，从而减少其对系统的影响。

**慢节点对系统性能的影响：**

1. 信息传播延迟： 如果一个节点的响应速度很慢，它可能在信息传播中引入延迟。其他节点在选择邻居节点时可能会受到慢节点的制约，导致整体信息传播的延迟。

2. 一致性问题： 如果慢节点的存在导致信息传播的不同步，可能会影响系统的一致性。慢节点可能在某个时刻看到的信息与其他节点不一致。

3. 系统稳定性： 长时间存在慢节点可能影响系统的稳定性。系统需要具备一定的自适应性和容错性，以适应节点状态的变化。

在设计和实现 Gossip 协议时，需要考虑如何有效地处理慢节点，使系统能够适应节点的动态变化，并在一定程度上减轻慢节点对系统性能的影响。

### 预防节点欺骗
Gossip 协议通常采用一些机制来防止节点欺骗攻击，即节点发送虚假的消息或篡改信息以影响系统的一致性。节点欺骗攻击可能对系统的性能和一致性产生负面影响，因此需要一些对抗措施。

1. 数字签名
2. 身份验证
3. etc.

### 面对网络分区
gossip保证**局部一致性**即可.