# operating system

## 操作系统基础 
1. 操作系统有哪些基础组成部分?
- Processes and Threads
- Memory Management
- File System
- I/O

## Processes
1. 什么是进程
   1. 进程就是一个正在执行程序的实例
   2. 进程是资源分配和拥有的基本单位

2. 进程的状态
   1. running: 正处在时间片内
   2. ready: 时间片完,在等待下一个时间片
   3. blocked: 等待输入

3. 什么是上下文切换？


   1. 上下文切换（Context Switching）是指计算机操作系统在多任务（Multitasking）或多线程（Multithreading）环境下，从一个正在执行的进程或线程切换到另一个进程或线程的过程。在多任务操作系统中，多个进程或线程共享CPU时间，并且通过轮询、优先级调度等机制来切换执行的任务。上下文切换是实现这种切换的核心操作之一。

4. 进程间通信:

   1. 什么是**管道**（pipe）？它可以用于哪些类型的进程通信？
      1. 匿名管道 ->父子进程之间
      2. 命名管道 ->不同计算机进程之间

   2. 什么是**消息队列**（message queue）？它与管道有什么不同？

      1. 消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；

      1. 避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；

      1. 读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。

   3. 什么是**共享内存**（shared memory）？它与消息队列和管道有何异同？

      1. 类似多线程读写

5. 什么是**信号**（signal）？它用于什么场景？操作系统中的信号量机制是什么？如何使用信号量实现进程同步和互斥？

   1. 处理异常
   2. 进程间通信
   3. 通知事件
   4. 进程控制

6. 什么是**套接字**（socket）？它用于哪些类型的进程通信？

   1. 套接字（Socket）是一种用于实现网络通信和进程间通信的编程接口，它提供了一种标准的方法，允许不同计算机上的进程进行数据交换。

7. 进程间通信的机制有哪些优缺点？如何选择合适的通信机制？

8. 进程间的资源竞争有哪些种类？
   1. 竞争条件;
   2. 死锁;
   3. 饥饿;
   4. 锁竞争;

9. 操作系统是如何保证多个进程并发执行的？
     1. 时间片轮转调度;
     2. 进程切换;
     3. 多核处理器;
     4. 进程同步和互斥;

10. 操作系统中的进程同步机制有哪些？如何解决进程同步的问题？

11. 操作系统中如何实现文件的共享和保护？

12. 什么是进程调度？常用的调度算法有哪些？

    1. 只要有两个以上的进程或线程竞争C一个PU,CPU就要使用**调度算法**选择下一个执行谁;
    2.  **先来先服务 first-come first-serverd（FCFS）**
    3. **短作业优先 shortest job first（SJF）**
    4. **最短剩余时间优先 shortest remaining time next（SRTN）**
    5. **时间片轮转**
    6. **优先级调度**
    7. **多级反馈队列**

13. 什么是远程过程调用（RPC）？它与进程间通信有何异同？

    1. 远程过程调用（Remote Procedure Call，RPC）是一种分布式计算的通信模式，允许程序调用另一个地址空间（通常是在不同计算机上）中的函数或方法，就像本地函数调用一样。RPC允许在网络上远程调用远程主机上的函数，使分布式应用程序能够协同工作，共享数据和服务。RPC的基本思想是隐藏了底层通信细节，使远程调用看起来就像本地调用一样，使开发分布式系统更加方便。
    2. RPC提供了更高级别的抽象和更大的灵活性，使跨网络的通信更容易，而进程间通信通常更适用于本地进程之间的通信，通常需要更多的手动管理和维护。

14. 什么是活锁？如何避免活锁？

    1. 活锁（Livelock）是一种多线程编程中的并发问题，它类似于死锁，但不同之处在于线程不会被阻塞，而是持续尝试解决冲突，却一直无法取得进展，导致线程无法完成其任务。活锁通常发生在多个线程之间争夺资源或锁时，它们采取了一种过于主动的方式来避免竞争，最终导致了互相干扰，无法前进。
## Threads
1. 什么是线程
   1. 程序执行的基本单位
3. 死锁
   1. 什么是死锁

   - 死锁是指两个（多个）线程相互等待对方数据的过程，死锁的产生会导致程序卡死，不解锁程序将永远无法进行下去。
   
   2. 死锁产生的条件: 理论上认为死锁产生有以下四个必要条件，缺一不可:	
   - **互斥条件**：进程对所需求的资源具有排他性，若有其他进程请求该资源，请求进程只能等待。
   - **不剥夺条件**：进程在所获得的资源未释放前，不能被其他进程强行夺走，只能自己释放。
   - **请求和保持条件**：进程当前所拥有的资源在进程请求其他新资源时，由该进程继续占有。
   - **循环等待条件**：存在一种进程资源循环等待链，链中每个进程已获得的资源同时被链中下一个进程所请求。
   3. 如何避免死锁

   - 保证上锁的顺序一致

7. 进程和线程的比较
   1. 调度: 线程是**资源调度**的基本单位; 进程是拥有资源的基本单位
   2. 并发性:一个进程内多个线程可以并发（最好和CPU核数相等）；多个进程可以并发。
   3. 拥有资源：线程不拥有系统资源，但一个进程的多个线程可以共享隶属进程的资源；进程是拥有资源的独立单位。
   4. 系统开销：线程创建销毁开销小; 进程大;

4. 什么是线程池？如何实现线程池的管理和调度？

   1. 线程池是一种用于管理和调度线程的并发编程工具，它可以帮助有效地管理线程的生命周期、复用线程以减少线程创建和销毁的开销，以及控制并发任务的执行。
   2. 任务队列：用于存储待执行的任务，这些任务可以是函数、方法或其他可执行单元。
   3. 线程池管理器：用于创建、初始化和管理线程池的线程。
   4. 工作线程：用于实际执行任务的线程。这些线程从任务队列中获取任务并执行它们。

5. 什么是事件驱动编程（event-driven programming）？它与异步编程有何关系？


   1. 事件驱动编程的核心思想是，程序执行的控制流程由外部事件的发生和触发来驱动，而不是通过顺序执行的方式。

   2. 异步编程是一种处理事件的方式，它涉及在事件触发后，不会立即阻塞当前线程等待事件处理完成，而是通过回调函数、Promise、async/await等机制，允许程序继续执行其他任务。异步编程允许程序有效地处理事件，而不会阻塞主线程，提高了程序的并发性和响应性。

   3. 在同步模型中，任务按照固定的顺序依次执行，一个任务完成后才会开始下一个任务。任务之间是依赖性的，后续任务必须等待前一个任务完成。

6. 线程的并发和并行有什么区别？


   1. 并发是指多个任务交替执行，它们共享CPU时间，每个任务在一段时间内都有机会执行。这种交替执行可以通过时间片轮询、任务切换等机制实现。

   2. 并行是指多个任务同时执行，每个任务都在不同的CPU核心或处理器上执行。并行要求系统具有多个执行单元，以便多个任务可以同时运行。

7. 什么是线程局部存储？

   1. 线程局部存储（Thread-Local Storage，TLS）是一种编程机制，允许每个线程在多线程应用程序中拥有自己的独立变量副本。这意味着每个线程可以访问和修改其自己的变量，而不会干扰其他线程的同名变量。线程局部存储用于解决多线程之间数据隔离和线程安全性的问题。

8. 线程的栈和堆有什么区别？


   1. 线程的栈主要用于存储函数调用的局部变量、函数参数、返回地址以及函数调用的上下文信息。

   2. 线程的堆用于存储动态分配的内存，例如使用`new`、`malloc`或其他动态分配内存的方式。

9. 什么是用户线程和内核线程？它们的区别是什么？


   1. 用户线程是由用户空间的线程库或应用程序自行管理的。操作系统对用户线程一无所知，不直接支持用户线程的创建、调度和管理。

   2. 内核线程由操作系统内核直接管理，包括线程的创建、调度、切换和销毁。操作系统了解内核线程的存在并支持多线程应用程序。

10. 什么是协程？如何实现协程？

    1. 用户态的轻量级线程，线程内部调度的基本单位

11. 线程同步的方式有哪些？


    1. mutex

    2. semaphore

    3. condition variable

       1. 条件变量（Condition Variable）是一种线程同步机制，用于在线程之间建立条件等待和通知机制。它允许一个线程等待某个条件成立，而其他线程可以通知等待线程条件已满足，以便等待线程继续执行。

    4. read-write lock

       1. 允许多个线程同时获取读锁, 只允许一个线程获取写锁

    5. spinlock

       1. 自旋锁（Spinlock）是一种线程同步机制，通常用于实现互斥锁（Mutex）的一种形式。与互斥锁不同，自旋锁不会将线程置于休眠状态，而是在等待锁变为可用时，线程会忙等（自旋）直到锁可用。

    6. recursive lock


       1. 递归锁通常用于处理递归函数或递归调用中的同步问题，允许递归函数在不同层次上继续使用同一个锁。


       1. 不同线程之间的锁获取和释放行为仍然遵循互斥的原则，即同一时刻只有一个线程可以持有锁。

12. 什么是阻塞和非阻塞？请分别介绍阻塞和非阻塞的概念、优缺点以及使用场景。

    **阻塞（Blocking）**：

    - **概念**：在阻塞模型中，一个操作或线程会等待某个事件发生或某个条件满足，然后才继续执行。在等待期间，线程会挂起，不执行其他任务。
    - **优点**：
      - 简单：阻塞模型通常更容易编写和理解，因为它反映了自然的顺序和依赖关系。
      - 可控：操作的执行顺序是可控的，可以确保任务按照特定的顺序执行。
    - **缺点**：
      - 低效：如果一个操作需要等待很长时间才能继续执行，它将阻塞线程，导致性能下降。
      - 难以实现并发：在多任务环境中，阻塞模型可能会导致线程等待，从而浪费资源。
    - **适用场景**：
      - 当任务之间有依赖关系，后续任务需要等待前一个任务完成时，阻塞模型是合适的，如顺序执行的处理流程。

    **非阻塞（Non-blocking）**：

    - **概念**：在非阻塞模型中，一个操作或线程不会等待事件或条件的发生，而是继续执行，并定期检查事件或条件是否已满足。如果条件未满足，操作会返回或继续执行其他任务。
    - **优点**：
      - 高效：非阻塞模型充分利用了计算资源，不会浪费时间在等待上。
      - 高并发：在多任务环境中，非阻塞模型能够更好地处理并发，因为它不会阻塞线程，允许多个任务并行执行。
    - **缺点**：
      - 复杂：非阻塞模型通常更复杂，因为它需要实现轮询和条件检查，而且需要处理竞态条件。
      - 可能导致忙等待：在非阻塞模型中，轮询事件或条件可能导致忙等待，占用了CPU资源。
    - **适用场景**：
      - 高并发环境：非阻塞模型适用于需要高并发性能的场景，如网络服务器、多线程应用程序等。
      - 响应性要求高：当需要快速响应事件或条件变化时，非阻塞模型可以提供更好的响应性。

## Memory Management
1. 什么是虚拟内存？它的实现原理和作用是什么?

   虚拟内存（Virtual Memory）是一种计算机操作系统的内存管理技术，用于扩展物理内存的容量，使程序可以访问比实际物理内存更大的地址空间。虚拟内存的实现原理和作用如下：

   1. 实现原理：

      虚拟内存的实现原理涉及到物理内存、虚拟地址空间、页面文件和页表等概念：

      虚拟地址空间：每个进程都有自己的虚拟地址空间，通常是一个连续的地址范围，从0开始，最大取决于硬件和操作系统。这个地址空间被划分为多个固定大小的块，称为页。

      物理内存：计算机的物理内存是实际可用的内存资源，是用于存储程序和数据的地方。

      页面文件：虚拟内存技术需要一个磁盘上的特殊文件，称为页面文件（page file）或交换文件（swap file）。页面文件用于暂时存储虚拟内存中的页，当物理内存不足时，可以将一部分页面移至磁盘，以便为其他页面腾出空间。

      页表：每个进程都有一个页表，用于将虚拟地址映射到物理地址。页表中的条目指示虚拟地址与物理地址之间的映射关系。当程序访问虚拟地址时，操作系统使用页表将其映射到相应的物理地址。

   2. 作用：

      虚拟内存的作用包括：

      **内存隔离**：每个进程拥有自己的虚拟地址空间，使它们互相隔离，一个进程的错误不会直接影响其他进程。

      **扩展地址空间**：虚拟内存允许程序访问比物理内存更大的地址空间。当程序需要更多内存时，操作系统可以将不常用的页面移至磁盘，从而扩展可用地址空间。

      **页面置换**：当物理内存不足时，操作系统可以将不常用的页面移到磁盘，并将需要的页面加载到物理内存中。这个过程称为页面置换。

      **安全性**：虚拟内存可以通过内存保护机制确保进程无法访问其他进程的内存，提高系统的安全性。*

      **虚拟内存交换**：允许将整个进程交换到磁盘上，以便在需要时重新加载。这有助于节省内存资源。

   总之，虚拟内存是一种强大的内存管理技术，它提供了内存隔离、扩展地址空间、页面置换和安全性等重要功能，以优化多任务操作系统的性能和可靠性。虚拟内存允许操作系统更有效地管理内存资源，使多个进程能够共享硬件资源，并提高系统的稳定性。
2. 内存管理中的分页和分段有什么区别？分页的页表如何设计?
   1. paging: 内存被划分为等大小的固定块
   2. segmentation: 内存被划分为不同大小的段，每个段有自己的大小和属性（例如，代码段、数据段等）。(更灵活, 管理更复杂)
3. 什么是缺页中断？如何处理缺页中断？ 
   1. 缺页中断（Page Fault）是计算机操作系统中的一种中断（异常），当程序尝试访问虚拟内存中的某个页面（页）但该页面当前不在物理内存中时，就会触发缺页中断。
   2. 页面替换;
5. 什么是内存映射？内存映射的作用是什么？在哪些情况下会用到内存映射？
   1. 内存映射是一种将文件或其他设备中的数据映射到进程的地址空间的技术。内存映射允许进程像访问内存一样访问文件的内容或设备的数据，而不需要显式地读取或写入文件或设备。
   2. 文件映射; 共享内存;
6. 什么是交换空间？交换空间的作用是什么？如何设置交换空间？
   1. 交换空间的主要作用是在物理内存不足时，充当辅助内存的角色，允许操作系统将不常用的内存页面（页）暂时存储到磁盘上，从而腾出物理内存以供其他程序使用。
8. 什么是物理地址和逻辑地址？它们之间的关系是什么？
   1. 逻辑地址：逻辑地址也称虚拟地址，是由程序或进程使用的地址。它是相对于进程的地址空间的地址，不直接对应物理内存中的位置。逻辑地址通常由程序员或操作系统管理，用于访问进程的内存。
9. 什么是快表？快表的作用是什么？如何实现快表？
   1. 快表（Translation Lookaside Buffer，简称TLB）是计算机系统中的一种高速缓存，用于加速虚拟地址到物理地址的转换过程，以提高内存访问的性能。
   2. TLB的主要作用是存储最近的虚拟地址到物理地址的映射关系，以便在访问内存时快速查找转换结果，而不必每次都访问页表进行映射。
10. 什么是写时复制技术？写时复制技术的原理是什么？在哪些情况下会用到写时复制技术？
   1. 写时复制（Copy-on-Write，简称COW）技术是一种用于管理内存和数据的高效策略，它的主要原理是将数据的复制推迟到实际需要修改数据时才进行，而不是立即复制数据。

## IO & File System
1. 什么是缓存？缓存如何提高系统的性能？
   1. 缓存是计算机系统中的一种用于存储临时数据的高速存储设备或存储区域，其主要目的是提高系统的性能。缓存工作原理是在存储数据时使用更快的存储介质或位置，以加速数据的访问和提高响应时间。
   2. 缓存层次结构;
   3. 缓存置换策略;
   4. 缓存命中;
2. 什么是文件系统？文件系统的组成部分有哪些？
   1. 文件系统的主要目的是提供一种层次化的、结构化的方式来存储和访问数据。
3. 什么是文件描述符？文件描述符的作用是什么？
   1. 文件描述符是一个在操作系统中用于标识和访问已打开文件的整数值。它是一个抽象概念，通常表示为非负整数。文件描述符是与文件、套接字、管道和其他输入/输出设备相关联的句柄，用于唯一标识这些资源并进行读取和写入操作。
   2. 文件描述符唯一标志文件;
   3. 可以用文件描述符读写文件.
   ```c
   #include <fcntl.h>
   #include <stdio.h>
   #include <unistd.h>

   int main() {
      int fd; // 文件描述符

      // 使用 open 系统调用打开文件（在当前目录下创建名为 example.txt 的文件）
      fd = open("example.txt", O_WRONLY | O_CREAT, 0644);

      if (fd == -1) {
         perror("open"); // 打印错误信息
         return 1;
      }

      // 文件打开成功，可以使用文件描述符进行读写操作

      // 关闭文件
      close(fd);

      return 0;
   }

   ```

      在这个示例中，read系统调用用于从已打开的文件描述符fd中读取数据，然后使用write系统调用将读取的数据写入标准输出（标准输出的文件描述符为STDOUT_FILENO）。这是一个非常基本的文件操作示例，展示了如何使用文件描述符进行文件读写操作。