# 数据系统的基石

## 可靠性、可维护性、可拓展性

1. **数据密集型**和**计算密集型**的区别是什么？
   1. 数据密集型应用程序受制于**数据量**、**数据复杂性**、以及**数据的变更速度**；
   2. 计算密集型应用程序受制于**CPU速度**。
2. 有哪些衡量分布式系统好坏的指标？
   1. 可靠性： 系统在**困境（adversity）**（硬件故障、软件故障、人为错误）中仍可正常工作（正确完成功能，并能达到期望的性能水准）。
   2. 可拓展性： 系统在**困境（adversity）**（硬件故障、软件故障、人为错误）中仍可正常工作（正确完成功能，并能达到期望的性能水准）。
   3. 可维护性： 许多不同的人（工程师、运维）在不同的生命周期，都能高效地在系统上工作（使系统保持现有行为，并适应新的应用场景）。
3. 分布式系统有哪些常见的故障?
   1. 软件故障;
   2. 硬件故障;
   3. 人为故障;
4. 有哪些描述性能的指标?
   1. 算术平均数: 隐藏了有多少用户实际上经历了极端情况;
   2. **百分位点**很好的表现了这个情况。
5. 什么是水平扩展和垂直扩展？
   1. horizontal scaling: 将负载分不到多台小机器;
   2. vertical scaling: 转向更强大的机器。
   3. 但是高端机器可能非常昂贵， 所以非常密集的负载通常无法避免地需要横向扩展。
6. 什么是无状态服务和有状态服务？
   1. 无状态服务的服务端不会保存任何关于前一次请求的信息。

## 数据模型与查询语言

1. 什么是关系型数据模型，它的优缺点是什么？
   1. 用表格（关系）来表示和存储数据的数据模型。
   2. 主键： 每个表格通常有一个主键，用于唯一标识表中的每个记录。
   3. 外键： 表格之间可以通过外键建立关系，实现数据的关联性。
   4. 缺点：固定的模式、拓展性不高。
2. 什么是 NoSQL 数据库，它的优缺点是什么？
   1. NoSQL（Not Only SQL）数据库是一类不依赖于传统的关系型数据库模型的数据库系统。这些数据库系统采用了不同的数据模型，包括**文档型**、**键值对型**、**列族型**和**图型**等，以满足不同类型和规模的数据存储需求。NoSQL数据库的出现是为了解决关系型数据库在某些方面的限制。
   2. 优点：
      1. 灵活的数据模型；
      2. 分布式架构；
      3. 无固定模式；
   3. 缺点：
      1. 分布式环境下一致性和事务的处理；
      2. 查询语言不同意。
3. 什么是文档数据库？它和关系型数据库有什么区别？
   1. 文档数据库是一种 NoSQL 数据库，其数据模型基于文档的表示形式，通常使用像 JSON 或 BSON 这样的格式。数据以文档为单位存储，每个文档可以包含不同结构的字段，允许嵌套和非规范化的数据。MongoDB 是一个常见的文档数据库例子。
   2. 特点：
      1. **文档模型：** 数据以文档的形式存储，文档是键值对的集合，可以包含嵌套的文档和数组。

      2. **水平扩展：** 支持水平扩展，能够在多个节点上分布数据。

   3. 文档数据库与关系型数据库的区别：

      1. **数据模型：**
         - 关系型数据库使用**表格**的结构，其中每行是一个记录，每列是一个属性。数据需要预定义表结构。
         - 文档数据库使用**文档**的结构，每个文档是一个自包含的单元，不需要预定义的模式，可以包含不同结构的字段。

      2. **数据一致性和事务：**
         - 关系型数据库通常提供强一致性和事务支持，确保数据的完整性。
         - 文档数据库在一致性和事务方面可能相对较弱，特别是在分布式环境中。

      3. **应用场景：**
         - 关系型数据库适用于需要强调事务处理和数据一致性的应用，如金融系统、订单处理等。
         - 文档数据库适用于半结构化和非结构化数据的场景，如内容管理系统、博客平台、实时协作工具等。

4. 什么是图数据库？它适用于哪些场景？
   1. 图数据库是一种特殊类型的数据库，专门设计用于存储和处理图形数据结构。图数据库的数据模型基于图的概念，其中包含节点（表示实体）和边（表示节点之间的关系）。图数据库通过这些节点和边的连接关系来表示复杂的关联性数据。
   2. 图数据库的特点：

      1. **节点：** 表示实体的基本单元，可以包含属性描述实体的特征。

      2. **边：** 表示节点之间的关系，可以包含属性描述关系的特征。

      3. **灵活的关系模型：** 图数据库能够轻松表示实体之间复杂的关系，适用于多对多关系的场景。

      4. **高效的遍历能力：** 图数据库在处理需要深度遍历关系的查询时具有优势，例如社交网络中的朋友关系。

   3. 图数据库适用的场景：

      1. **社交网络：** 用于存储和查询用户之间的关系，以及社交网络中的朋友、关注等连接。

      2. **推荐系统：** 用于分析用户与商品之间的关系，实现个性化的推荐算法。

      3. **网络分析：** 用于分析网络拓扑结构、路径规划等，如路网图。

      4. **知识图谱：** 用于构建和查询知识图谱，表示实体之间的语义关系。

      5. **身份和访问管理：** 用于表示用户和资源之间的权限关系，支持复杂的授权模型。

      6. **生物信息学：** 用于存储基因、蛋白质等生物实体及其相互作用关系。

   4. 优点：

      1. **处理复杂关系：** 图数据库在处理实体之间复杂的关联性数据时非常高效。

      2. **灵活的数据模型：** 适应多对多关系，支持动态添加节点和边。

      3. **高效的遍历：** 在需要深度遍历关系的查询场景下具有较高性能。

   5. 缺点：

      1. **不适用于简单查询：** 在简单的数据检索场景下，图数据库可能过于复杂。

      2. **数据结构相对固定：** 虽然图数据库具有灵活的模型，但在某些方面相对于文档数据库和关系型数据库较为固定。

5. 什么是键值数据库？它适用于哪些场景？

   1. 键值数据库是一种基于简单键值对存储的 NoSQL 数据库。在键值对中，键是唯一的标识符，而值则是与该键相关联的数据。这种数据库模型简单直接，适用于需要快速存取和检索数据的场景。典型的键值数据库包括 Redis 和 Amazon DynamoDB。

   2. 键值数据库的特点：

      1. **简单的数据模型：** 数据以键值对的形式存储，没有复杂的结构，适合存储简单的数据。

      2. **快速的读写操作：** 键值数据库通常提供快速的读写操作，适用于需要高性能的场景。

      3. **高度可扩展：** 多数键值数据库支持水平扩展，能够在多个节点上分布数据。

      4. **灵活的存储：** 可以存储各种类型的数据，如字符串、整数、二进制数据等。

   3. 键值数据库适用的场景：

      1. **缓存系统：** 用于存储经常访问的数据，提高访问速度。

      2. **会话存储：** 适合存储用户会话信息，如用户登录状态。

      3. **计数器应用：** 用于实现简单的计数器功能，如网站访问次数统计。

      4. **配置管理：** 存储系统配置信息，支持快速的配置检索。

      5. **分布式锁：** 用于实现分布式系统中的锁机制。

      6. **实时分析：** 适用于存储实时分析数据，如日志信息。

   4. 优点：支持水平扩展，适应大规模数据存储需求。

   5. 缺点：

      1. **不适用于复杂查询：** 由于简单的键值模型，不适用于需要复杂查询和关联操作的场景。

      2. **有限的数据处理能力：** 不如文档型数据库或关系型数据库支持复杂的数据处理。

## 存储与检索

1. 什么是索引？有哪些常见索引？
   1. 精心选择的索引加快了读查询的速度，但是每个索引都会拖慢写入速度。
   2. 常见索引: hash index、LSM、B树；
2. 机械硬盘和固态硬盘在性能上有什么区别？
   1. 机械硬盘：使用旋转的磁盘和机械臂进行数据存取；
   2. 固态硬盘：使用闪存存储；
3. OLAP和OLTP的区别是什么？
   1. 在高层次上，我们看到存储引擎分为两大类：优化 **事务处理（OLTP）** 或 **在线分析（OLAP）** 。
   2. OLTP面向用户，可能收到大量请求， 但对每个请求通常只需要查询一部分够用就行；
   3. OLAP: 数仓主要供专业分析人员使用, 查询量少, 但是单个查询开销高昂。

### 描述Bitcask的架构

1. Bitcask 的数据结构是什么？如何实现数据的快速读取和写入？
   1. hash表；
   2. 先根据key找到offset，再根据offset快速定位key在数据文件中的位置。
2. Bitcask 如何保证数据的一致性和可靠性？如何处理数据的冲突？
   1. 采用**追加写入**， 从而利用文件系统确保操作的原子性；
   2. 定期合并， 定期备份，从而确保可靠性；
   3. 数据冲突时采用**最后写入原则**，系统会采用最后写入的值，覆盖之前的值；
3. 如何进行 Bitcask 的数据备份和恢复？
   1. 数据备份：停止写入 -> 备份存储键值对的数据文件 -> 备份Hint文件(存储的是index)
   2. 数据恢复: 还原数据文件和Hint文件 -> 启动Bitcask服务 -> 恢复写入
4. Bitcask 的适用场景是什么？它和其他存储引擎的区别是什么？
   1. 读取和写入操作频繁;
   2. **追加**是他的特点;

### LSM（Log-Structured Merge Tree）

1. 什么是 LSM 树？
   1. 写入时，将其添加到内存中的平衡树数据结构（例如，红黑树）。这个内存树有时被称为**内存表（memtable）**。
   2. 当**内存表**大于某个阈值（通常为几兆字节）时，将其作为SSTable文件写入磁盘。这可以高效地完成，因为树已经维护了按键排序的键值对。新的SSTable文件成为数据库的最新部分。当SSTable被写入磁盘时，写入可以继续到一个新的内存表实例。
   3. 为了提供读取请求，首先尝试在内存表中找到关键字，然后在最近的磁盘段中，然后在下一个较旧的段中找到该关键字。
   4. 有时会在后台运行合并和压缩过程以组合段文件并丢弃覆盖或删除的值。
   5. 如果数据库崩溃，则最近的写入（在内存表中，但尚未写入磁盘）将丢失。为了避免这个问题，我们可以在磁盘上保存一个单独的日志，每个写入都会立即被附加到磁盘上。该日志不是按排序顺序，但这并不重要，因为它的唯一目的是在崩溃后恢复内存表。每当内存表写出到SSTable时，相应的日志都可以被丢弃。
3. LSM 树如何解决数据冲突问题？  
最后写入策略
4. LSM 树的优点是什么？  
高性能写入, 频繁写入场景
5. LSM 树的缺点是什么？
读取性能低

### B树

1. 什么是 B 树？

   B 树（B-Tree）是一种自平衡的搜索树数据结构，常被用于实现关系型数据库的索引结构。B 树具有以下主要特征：

   1. 平衡树结构： B 树是一种自平衡的树结构，保持了从根节点到叶子节点的深度相等，使得每个查询操作的时间复杂度为 O(log n)。
   2. 分支因子： B 树的每个节点可以拥有多个子节点，而不仅仅是两个。这个多个子节点的数量称为分支因子（branching factor），通常用符号 t 表示。B 树的节点上至多有 2t-1 个关键字。
   3. 有序性： 每个节点中的关键字都是有序排列的，使得对整个树进行范围查询非常高效。
   4. 高度平衡： B 树的自平衡性质确保了整个树的高度是相对平衡的，这有助于维持查询的高效性。
   5. 适用于外存储： 由于 B 树的设计考虑了磁盘读写的效率，它通常被广泛用于实现数据库索引，特别是在关系型数据库中。

3. B 树的基本操作:
   1. 搜索操作：  
   B 树的搜索操作类似于二叉搜索树，但有一些差异：

   - 从根节点开始： 从树的根节点开始，比较要搜索的关键字与节点中关键字的大小，根据比较结果确定向左还是向右子树移动。

   - 多分支： 由于 B 树节点可以包含多个关键字，搜索过程需要在节点中按序查找。

   - 递归： 如果在非叶子节点上找到了对应的关键字，递归地在相应的子树中继续搜索。如果在叶子节点上找到了对应的关键字，则搜索成功。

2. 插入操作：
   B 树的插入操作可能涉及到节点的分裂。

   - 从根节点开始搜索： 首先，从根节点开始搜索要插入的位置。

   - 找到插入位置： 如果找到了合适的叶子节点，将新的关键字插入到该节点中。如果插入后节点的关键字数量超过了规定的最大值，执行分裂操作。

   - 分裂操作： 将节点中的关键字一分为二，将中间值提升到父节点。这可能会导致父节点的关键字数量超过最大值，也需要进行分裂。如果父节点的分裂导致根节点的分裂，树的高度会增加。

3. 删除操作：
   B 树的删除操作可能涉及到节点的合并。

   - 从根节点开始搜索： 从根节点开始搜索要删除的关键字。

   - 找到删除位置： 如果找到了要删除的关键字，执行删除操作。如果删除导致节点中关键字的数量低于最小值，执行合并操作。

   - 合并操作： 将相邻的节点进行合并，同时将父节点中的相应关键字删除。这可能会导致父节点关键字数量低于最小值，需要递归执行合并操作。

   - 递归向上： 删除操作可能会导致递归向上，一直到根节点。如果根节点的关键字数量减为零，可以降低树的高度。
6. B 树的时间复杂度是多少？  
   分裂和合并操作确保了树的平衡，使得查询、插入和删除的时间复杂度保持在 **O(log n)** 的水平。

## 编码与演化

1. 什么是 Protocol Buffers？  
   Protocol Buffers，简称为 Protobuf，是由Google开发的一种轻量级、高效的数据交换格式。它可以用于结构化数据的序列化，可用于通信协议、数据存储等领域。
2. Protocol Buffers 相比于 XML 和 JSON 有什么优点？  
   与 XML 和 JSON 相比，Protocol Buffers 在序列化和反序列化的速度、数据体积上都具有优势。
   1. protocol buffer 使用二进制格式进行数据序列化, json/xml使用的是文本格式;
   2. 跨平台和语言;
   3. 向后兼容性: 旧程序在读取到新字段时会跳过, 保证了向后兼容;
3. Protocol Buffers 的三个核心组件是什么？
   message, field, enum;

   ```protobuf
      syntax = "proto3";

      message Person {
         int32 id = 1;
         string name = 2;
         string email = 3;
      }
   ```

   在 proto3 中，所有的字段都被视为是可选的，而且不再使用 required 和 optional 关键字。

# 分布式数据

## 复制
1. 同步复制和异步复制的区别？
   ![Alt text](./image/image.png)
2. 什么是分布式系统复制？

   ​ 如果复制中的数据不会随时间而改变，那复制就很简单：将数据复制到每个节点一次就万事大吉。复制的困难之处在于处理复制数据的变更（change）。我们将讨论三种流行的变更复制算法：单领导者（single leader），多领导者（multi leader）和无领导者（leaderless）。
3. 什么是主从复制和多主复制？
   1. 主从复制:
      1. 副本之一被指定为 领导者（leader），也称为 主库（master|primary） 。当客户端要向数据库写入时，它必须将请求发送给领导者，领导者会将新数据写入其本地存储。
      2. 其他副本被称为追随者（followers），亦称为read replicas, slaves, sencondaries, hot-standby. 每当领导者将新数据写入本地存储时，它也会将数据变更发送给所有的追随者，称之为复制日志（replication log）记录或变更流（change stream）。每个跟随者从领导者拉取日志，并相应更新其本地数据库副本，方法是按照领导者处理的相同顺序应用所有写入。
      3. 当客户想要从数据库中读取数据时，它可以向领导者或追随者查询。 但只有领导者才能接受写操作（从客户端的角度来看从库都是只读的）。
4. 主从复制中的读写一致性如何保证？  
   读己之写:
   ![Alt text](./image/image-1.png)
   因此, 我们需要读写一致性(read-after-write consistency).
   > 这是一个保证，如果用户重新加载页面，他们总会看到他们自己提交的任何更新。它不会对其他用户的写入做出承诺：其他用户的更新可能稍等才会看到。它保证用户自己的输入已被正确保存。
   我们提供一些方法来保证读写一致性:
      1. 读用户可能已经修改过的内容时，都从主库读；
      2. 客户端可以记住最近一次写入的时间戳，系统需要确保从库为该用户提供任何查询时，该时间戳前的变更都已经传播到了本从库中。
      3. 可以跟踪上次更新的时间，在上次更新后的一分钟内，从主库读。
   
   单调读: 时光倒流:
   ![Alt text](./image/image-2.png)
   ​ 实现单调读取的一种方式是确保每个用户总是从同一个副本进行读取（不同的用户可以从不同的副本读取）。对用户id进行hash.

   一致前缀读:
   ![Alt text](./image/image-3.png)
5. 多主复制中的冲突如何处理？
   ![Alt text](./image/image-4.png)
   解决方案:  
   1. ​处理冲突的最简单的策略就是避免它们：如果应用程序可以确保特定记录的所有写入都通过同一个领导者，那么冲突就不会发生。
   2. 其他的处理逻辑表现相当不好。
6. 什么是基于日志的复制？如何实现基于日志的复制？
   1. master生成日志, log中包括了对数据的增删改操作;
   2. master将log传播给slave;
   3. slave接收到log后, 按照log的顺序将其中的操作逐个应用到本地的数据库上。这样，从节点的数据状态就会与主节点保持一致。
   4. 从节点在应用完一个日志操作后，可以向主节点发送确认信息，以便主节点知道哪些操作已经在从节点上完成。
7. 什么是心跳机制？如何实现心跳机制？

   心跳机制是分布式系统中用于检测和监控其他节点或服务状态的一种机制。通过定期发送心跳信号，节点可以确认其他节点的存活状态，从而及时检测到故障或失效，并采取相应的措施，比如进行故障转移或重新分配任务。

   实现心跳机制的基本思想是定期发送心跳消息，接收方节点在一定时间内未收到心跳消息则认为发送方节点失效。
8. 什么是数据一致性？如何保证数据一致性？
   1. 强一致性： 强一致性要求系统在任何时刻都对所有节点提供相同的数据视图。为了实现强一致性，可以使用同步复制或事务协议，确保在数据写入时，所有相关的节点都能够达到一致的状态。强一致性通常会引入一定的性能开销和延迟。

   2. 弱一致性： 弱一致性放宽了对数据一致性的要求，允许在某些时刻不同节点的数据存在短暂的不一致。弱一致性通常通过异步复制等方式来实现，允许系统在一段时间内存在数据的差异，然后通过后续的同步过程逐渐达到一致性。

   3. 最终一致性： 最终一致性是弱一致性的一种特例，它要求系统在经过一段时间后，最终能够达到一致的状态。最终一致性允许在数据写入时存在短暂的不一致，但最终会通过某种机制达到一致。这种方式通常更适用于分布式系统的设计，因为它能够提供更好的性能和可用性。
9. 什么是分布式一致性算法？常见的一致性算法有哪些？  
   分布式一致性算法是为了在分布式系统中保证多个节点或副本之间数据一致性而设计的算法。这些算法旨在解决在分布式环境下可能出现的网络分区、节点故障、消息延迟等问题，确保系统能够达到一致的状态。

   常见的consence algorithm: Paxos, Raft.
10. 什么是 Raft 算法？与 Paxos 算法有何区别？  
   1. Raft 算法：

   - 可理解性： Raft 算法的一个设计目标是更易于理解和实现。相对于 Paxos，Raft 的设计更加模块化，将分布式一致性问题分解为更容易理解的部分，包括领导选举、日志复制等。

   - 领导选举： Raft 引入了领导选举的概念，系统中的节点通过选举一个领导节点来协调数据的复制。只有领导节点才能处理客户端的写请求，这样简化了系统的状态管理。

   - 日志复制： Raft 使用一个逐个追加的日志复制机制，确保所有节点上的日志都按照相同的顺序进行操作。领导节点负责接收客户端的写请求，将写操作添加到日志中，并将日志复制给其他节点。

   - 保守的复制： Raft 采用保守的复制策略，只有在大多数节点都确认接收到日志后才认为一个日志项是提交的。这确保了一致性和分区容忍性。

   2. Paxos 算法：
   - 提出时间： Paxos 算法是在 Raft 之前提出的，它是分布式系统领域的经典算法之一。

   - 领导概念： Paxos 没有像 Raft 那样引入领导的概念，而是通过一个协议来保证多个节点之间的一致性。

   - 多阶段协议： Paxos 采用多阶段协议来达到一致性。它包括提议、接受和学习等阶段，以确保所有节点能够就一个值达成一致。

   - 可变角色： Paxos 中的节点角色可变，即一个节点可以在不同的提案中扮演不同的角色，例如提议者、接受者等。

   - 高度灵活： Paxos 算法比 Raft 更为通用和灵活，适用于不同的分布式系统场景，但相应地也更加复杂难以理解。

   总的来说，Raft 算法在设计上更注重可理解性和模块化，使得它更容易为开发者理解和实现。Paxos 算法更为通用，但相对而言更为复杂。选择使用哪种算法通常取决于具体的应用场景和对系统复杂性的容忍程度。
## 分区
1. 什么是分布式系统分区？
2.分布式系统分区有什么好处？
3. 什么是CAP理论？它如何解释分布式系统分区？
4. 什么是Quorum？它如何在分布式系统分区中发挥作用？
5. 什么是一致性哈希算法？它如何帮助解决分布式系统分区问题？
6. 什么是Gossip协议？它如何用于处理分布式系统分区问题？
7. 什么是分区容错？它如何与分布式系统分区相关？
## 事务
1. 什么是分布式系统事务？
2. 什么是ACID属性？在分布式系统事务中如何保证ACID属性？
3. 什么是BASE属性？在分布式系统事务中如何保证BASE属性？
4. 什么是两阶段提交协议？如何使用两阶段提交协议实现分布式系统事务？
5. 什么是三阶段提交协议？它相比两阶段提交协议有什么优势？
6. 什么是分布式锁？如何使用分布式锁来实现分布式系统事务？
## 分布式系统的麻烦
## 一致性与共识
1. 分布式系统有哪些一致性？他们之间的区别是？
2. 什么是分布式系统的两阶段提交协议（Two-Phase Commit Protocol）？
3. 两阶段提交协议的目的是什么？
4. 两阶段提交协议的优缺点是什么？
5. 什么情况下会发生两阶段提交协议的超时现象（Timeout）？
6. 什么是协调者（Coordinator）和参与者（Participant）？
7. 如何处理两个协调者之间的冲突？