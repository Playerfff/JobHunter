# Redis

Redis是一个**数据库**，不过与传统数据库不同的是Redis的数据库是存在**内存**中，所以**读写速度非常快**，因此 Redis被广泛应用于**缓存**方向。

除此之外，Redis也经常用来做分布式锁，Redis提供了多种数据类型来支持不同的业务场景。除此之外，Redis 支持事务持久化、LUA脚本、LRU驱动事件、多种集群方案。

### 应用场景

互联网高并发, mysql撑不住了, 必须使用in-memory的redis.

### Redis和mysql区别

1. mysql是传统数据库关系, redis是kv数据库,NoSQL数据库
2. redis在内存中, mysql在磁盘中
3. redis在某一些场景使用中明显优于mysql, 比如计数器、排行榜等

# C++中的Map也是一种缓存型数据结构，为什么不用Map，而选择Redis做缓存？

严格意义上来说缓存分为**本地缓存**和**分布式缓存**。

那以 C++ 语言为例，我们可以使用 STL 下自带的容器 map 来实现缓存，但只能实现**本地缓存**，它最主要的特点是轻量以及快速，但是其生命周期随着程序的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。

使用 Redis 或 Memcached 之类的称为**分布式缓存**，在多实例的情况下，各实例共享一份缓存数据，缓存具有一致性。这是Redis或者Memcached的优点所在，但它也有缺点，那就是需要保持 Redis 或 Memcached服务的高可用，整个程序架构上较为复杂。

# Redis 常用命令

- 命令**不区分大小写**, 而key**区分大小写**;

- 帮助命令: `help @类型`

1. `keys *`查看当前库所有的key
2. `exits key`判断某个key是否存在
3. `type key`查看你的key是什么类型
4. `del key`阻塞删除key
5. `unlink key`非阻塞删除key
6. `ttl key`查看key还有多少秒过期, -1表示永不过期, -2表示已过期
7. `expire key 秒钟` 为给定的key设置过期时间
8. `move key dbindex` 将当前数据库的key移动到给定的数据库db中
9. `dbsize` 查看当前数据库key的数量
10. `flushdb`清空当前库
11. `flushall`清空所有库

# Redis 10大数据类型

Redis provides [data structures](https://redis.io/docs/data-types/) such as [strings](https://redis.io/docs/data-types/strings/), [hashes](https://redis.io/docs/data-types/hashes/), [lists](https://redis.io/docs/data-types/lists/), [sets](https://redis.io/docs/data-types/sets/), [sorted sets](https://redis.io/docs/data-types/sorted-sets/) with range queries, [bitmaps](https://redis.io/docs/data-types/bitmaps/), [hyperloglogs](https://redis.io/docs/data-types/hyperloglogs/), [geospatial indexes](https://redis.io/docs/data-types/geospatial/), and [streams](https://redis.io/docs/data-types/streams/). 

## Strings

### Redis的string类型和常规字符串有什么区别？

Redis的string类型是二进制安全的，可以存储任何数据，而常规字符串通常指的是文本字符串



### Redis的string类型能存储的数据类型有哪些？

可以储存文本字符串，整数，浮点数，二进制数据



### 如何将一个key的value增加1？

INCR命令(atomic)



### 如何批量设置多个key-value对？

MSET 命令，将多个键值对一次性设置



### 如何使用Redis的string类型实现分布式锁？

使用SET命令设置键作为锁，使用NX选项来确保只有一个客户端可以成功设置键，实现互斥锁

- `NX` -- Only set the key if it does not already exist.

### 如何使用Redis的string类型实现分布式缓存？

将缓存数据序列化并存储在Redis的string类型中，使用缓存键来唯一标识不同的数据对象，并在需要时从Redis中获取缓存

### Redis的string类型的内存优化方式有哪些？

使用压缩列表（ziplist），使用Intset优化整数存储，使用Redis的LZF压缩来减少内存

## List

**单值多value**, value**有序有重复**

一个双端链表的结构, 容量是2的32次方-1个元素, 大概40多亿, 主要功能有push/pop, 一般用在栈、队列、消息队列等场景。

常见操作:

1. 列表左侧或右侧添加元素
2. 获取元素
3. 删除元素
4. 获取列表长度

### 如何使用Redis实现消息队列？

使用List类型，使用LPUSH将消息推入队列左侧，使用RPOP从队列的右侧弹出消息。

**只适合一对一,不太适合一对多(pub/sub)**

## Hash

还是kv键值对, 区别在于value还是一个kv键值对, 类似于`std::map<std::string, std::map<std::string, std::string>>`

常见操作:

1. hset/hget/hmset/hmget/hgetall/hdel
2. hlen, 获取hash长度
3. hexists key, 在key里面的某个值的key

应用场景:

​	常用于表示对象，特别适合存储和查询具有多个字段的数据，如用户信息、产品属性等

### Redis Hash 在并发情况下如何保证数据的一致性？

通过Redis的**单线程模型**和**原子操作**来保证数据一致性

### Redis Hash 和 Redis String 相比有什么优缺点？

- Redis Hash优点是可以存储多个字段的相关数据，适用于对象表示，但缺点是相对较复杂
- Redis String优点是简单且高效，但不适合表示复杂对象

### Redis Hash 和 Redis List 相比有什么优缺点？

- Redis Hash优点是适合存储和查询多个字段的数据，缺点是不适合按顺序遍历数据；

- Redis List优点是适合按顺序存储和遍历数据，缺点是不适合高效查询多个字段的数据。

### Redis Hash 的扩容机制是怎样的？

Redis Hash在达到一定大小时会自动扩容，将存储桶buckets的数量增加，并重新分布键值对

### Redis Hash 中的操作如何保证时间复杂度的稳定性？

Redis使用了哈希表来存储和检索字段和值，而哈希表的性能保持稳定，所以能保持O(1)

### Redis Hash 和 Memcached Hash 相比有什么优劣势？

Redis Hash相对于Memcached Hash的优势包括支持更丰富的数据结构和持久性，劣势是可能占用更多内存和处理速度较慢

### Redis Hash 在集群模式下如何处理数据分片和节点故障？

Hash数据会被分片到不同的节点上，集群会自动处理数据分片和节点故障的情况，保证高可用性和负载均衡

### Redis Hash 的内存管理是怎样的？

Redis Hash内存采用了一种散列表的数据结构，其中字段和值以紧凑的方式存储在内存中

## Set

**单值多value**, value**无序无重复**, 底层是hash table

常见操作:

1. SADD, 添加元素, 删除元素
2. SISMEMBER, 判断元素是否存在
3. 求SINTER交集SUNION并集SDIFF差集

### 应用场景

1. 共同好友
2. 微信抽奖小程序

### 有哪些优化？

优化包括压缩列表ziplist和散列表hashtable两种不同的数据结构以适应不同场景

### Redis Set 是否支持多线程并发操作？

支持，但不是多线程安全的，需要在应用层处理并发控制

## Zset（sorted set)

在set基础上, 每个val值前加一个score分数值.

常用操作:

1. ZADD, 添加成员及其分数
2. ZRANGE, 按分数范围获取成员
3. 按成员获取分数
4. 删除成员

### 如何使用Zset实现排行榜功能

排行榜功能可以使用ZADD命令添加成员及其分数，然后使用ZREVRANGE或其他相关命令按分数范围获取排名列表

## Bitmap

是一种数据结构，用于表示位图或位集合，常用于记录布尔值信息、标记某个事件是否发生、用户在线状态等，以高效地进行位级别的操作和统计。

应用场景

1. 电影、广告是否被点击播放过
2. 钉钉打卡上下班，签到统计
3. 每日签到

### Redis Bitmap 有哪些优点和缺点？在哪些场景下可以考虑使用它？

- 优点包括紧凑的内存占用、高效的位级别操作，适用于计数和状态跟踪等场景
- 缺点是不适合存储大范围的连续数据。可以在统计、计数、用户在线状态等场景中考虑使用

### 如何使用 Redis Bitmap 统计某个时间段内的用户在线时间？

Redis Bitmap可以为每个用户创建一个位图，位图中的每一位代表一个时间段，设置位表示用户在该时间段在线，然后使用位操作来统计用户在线时间。

### Redis Bitmap 和传统数据库相比，有哪些优势和劣势？如何权衡两者之间的使用？

- Redis Bitmap在位图操作方面具有高效性能，适用于处理大规模二进制数据，但不适合复杂查询和事务操作
- 权衡时需考虑数据量、查询需求和事务要求等因素

### 如果需要同时统计多个事件的发生次数，你会选择 Redis Bitmap 还是 Redis Hash？为什么？

Redis Hash更适合，因为它提供了更灵活的数据结构和易于查询的方式，以为每个事件创建一个字段，并以字段名作为事件的标识，然后使用 Hash 的 INCRBY 命令可以方便地递增每个事件的发生次数

### 如何使用 Redis Bitmap 实现布隆过滤器？它的原理是什么？

将每个元素的哈希值映射到位图的不同位上，检查和查询时查看相应位是否被设置；原理是基于位运算实现，允许高效地检查元素是否存在

### Redis Bitmap 的底层实现是怎样的？如何提高 Redis Bitmap 的性能？

底层实现是使用字节数组，可以通过位运算操作来设置、获取和统计位；提高Redis Bitmap性能，可以考虑使用命令管道、使用位操作进行批量操作以及合理选择内存数据结构大小

### 如何使用 Redis Bitmap 实现高性能的网站访问量统计功能？具体实现步骤是什么？

1. 为每个网页或文章创建一个唯一的标识符，例如文章ID或URL。
2. 使用Bitmap记录每个标识符对应的访问情况，每天一个Bitmap，每个位代表一天的访问情况（0表示未访问，1表示已访问）。
3. 使用SETBIT命令将相应的位设置为1来记录每次访问。
4. 使用BITCOUNT命令计算每篇文章或网页的访问量，以及按日期范围统计总访问量

## stream

Redis版的MQ消息中间件+阻塞队列

**队尾是新来的消息**

### 能干嘛

实现消息队列，他支持消息的持久化、支持自动生成全局唯一ID、支持ack确认消息的模式、支持消费组模式等，让消息队列更加的稳定和可靠

### 队列相关指令

- XADD 添加消息到队列末尾
- XRANGE / XREVRANGE 获取消息列表
- XDEL 删除消息
- XLEN 消息个数
- XTRIM 用于对stream的长度进行截取, 如超长会进行截取
- XREAD 用于获取消息(阻塞/非阻塞), 只会返回大于指定ID的消息

### 消费组相关指令

消费组的目的是让组内的多个消费者共同分担读取消息, 所以, 我们通常会让每个消费者读取部分消息, 从而实现消息读取负载在多个消费者间是均衡分布的

- XGROUP CREATE 用于创建消费者组
- XREADGROUP GROUP 注意:**不同消费组的消费者可以消费同一条消息**

### stream实现消息队列

生产者通过xadd发送数据到stream, 消费者通过xread读取数据.

### 基于stream实现的消息队列，如何保证消费者在发生故障或宕机再次重启后，仍然可以读取未处理完的消息？

1. streams会自动使用内部队列（PENDING LIST)留存消费组里每个消费者读取的消息报读措施, 知道消费者使用**XACK命令**通知streams"消息已经处理完成"
2. 消费确认增加了消息的可靠性, 一般在业务处理完成之后, 需要执行XACK命令确认消息已经被消费完成

### Redis Stream适用于哪些场景，与Kafka、RabbitMQ等消息队列相比，有什么优势和劣势？

- Redis Stream适用于实时数据流处理和消息传递场景，相对于Kafka和RabbitMQ，优势在于更轻量、易于配置

- 劣势是不适合大规模分布式系统和高吞吐量需求

### Redis Stream如何保证消息的顺序性？有哪些可能导致消息顺序性被打破的情况？

通过使用**消息的ID(递增)**来保证消息的顺序性；如果消息的ID生成不当或者删除了某些消息，消息顺序性可能被打破

### Redis Stream如何进行消息过期和删除？如何避免过期消息对消费者的影响？

通过设置消息的过期时间来进行消息过期和删除，并通过消费者组的XACK命令显式确认消息以避免过期消息对消费者的影响

### Redis Stream如何处理大规模数据集和高并发流量？如何避免消息堆积和系统崩溃？

处理大规模数据集和高并发流量的Redis Stream应采用适当的水位线（consumer group的acknowledge机制），合理控制消费者处理速度，以避免消息堆积和系统崩溃

## Redis持久化

Persistence refers to the writing of data to durable storage, such as a solid-state disk (SSD).

### 为什么需要 Redis 持久化？Redis 持久化的作用是什么？

持久化是为了在Redis服务器重启后恢复数据，以确保数据的持久性和可靠性

### Redis 持久化有哪两种方式，分别是什么？它们的区别是什么？

- RDB(snapshot): 定期将内存数据保存到磁盘形成.rdb文件
  - 优点:
    - 适合大规模的数据备份
    - 按照业务**定时备份**
    - 对数据完整性和一致性要求不高
    - RDB文件在内存中的加载速度要比AOF快
  - 缺点:
    - 如果redis在备份间隔时间宕机的话, 会丢失从当前至最近一次快照期间的数据
    - 内存数据的全量同步, 如果数据量太大会导致I/O,严重影响服务器性能
  - 触发机制
    - 配置文件中默认的快照配置
    - 手动save/bgsave命令
    - 执行flushall/flushdb命令也会产生dump.rdb文件, 但里面是空的
    - 执行shutdown且没有设置开启AOF持久化
    - 主从复制时, 主节点自动触发
- AOF(append only file): 以日志形式记录每个写操作, 只需追加文件不需修改文件
  - 工作流程
    - client->redis->AOF缓存区->AOF文件
    - client作为命令的来源，会有多个源头以及源源不断的请求命令
    - 在这些命令到达redis server以后并不是直接写入AOF文件，而是先将这些命令放入**AOF缓存区**进行保存。这里的AOF缓存区实际上以内存中的一片区域，存在的目的是当这些命令达到一定量以后再写入磁盘，避免频繁的磁盘IO操作
    - AOF缓存区会根据**同步文件的三种写回策略**将命令写入磁盘上的AOF文件
    - 随着写入AOF内容的增加，为避免文件膨胀，会根据规则进行命令的合并（又称**AOF rewrite**，从而起到AOF文件压缩的目的
  - 三种协写回策略
    - always：同步写回，每个写命令执行完立刻同步地将日志写回磁盘
    - everysec：每隔一秒将AOF缓冲区写到AOF文件上
    - no：每个写命令执行完，只是先把日志写到AOF缓冲区，由操作系统决定合适将缓冲区内容写回磁盘
  - AOF rewrite
    - 当AOF文件的大小超过所设定的峰值时，redis就会自动启动AOF文件压缩，只保留可以恢复数据的**最小指令集**
    - rewrite过程会将现有AOF日志文件中的命令重写到一个新的AOF文件中，删除旧的日志，以减少AOF文件大小，但可能会导致磁盘I/O负载增加
  - 优点:
    - 更好的保护数据不丢失、性能高、可做紧急恢复
  - 缺点：
    - AOF文件大，恢复慢

它们的区别在于:

RDB适用于备份和恢复整个数据集，而AOF可保证更小的数据丢失和更强的数据持久性

### Redis RDB 持久化和 AOF 持久化的恢复优先级是怎样的？

同时启用Redis的RDB和AOF持久化时，AOF持久化的恢复优先级高于RDB，Redis只会使用AOF日志，不会加载RDB来进行数据恢复

### Redis纯缓存模式

同时关闭RDB+AOF，只要求redis做缓存

## Redis 事务

### Redis 事务是什么？它有什么特点和优势？

Redis事务是一系列Redis命令的**打包**有序执行，具有原子性、隔离性、一致性和持久性的特点，优势在于可以将多个操作批量执行，保证了操作之间的一致性。

Redis通过MULTI、EXEC、DISCARD和WATCH命令来保证事务的原子性

### Redis事务 VS 数据库事务

1. 单独的隔离操作：Redis的事务仅仅是保证事务里的操作会被连续独占的执行，redis命令执行时单线程架构，在执行完食物内所有指令前是不可能再去同时执行其他客户端的请求的
2. 没有隔离级别的概念：redis事务提交前任何指令都不会被实际执行，也就不存在“事务内的查询要看到事务里的更新，在事务外查询不能看到”这种问题了
3. 不保证原子性：redis的事务不保证原子性，只有决定是否开始执行全部指令的能力，没有执行到一半进行回滚的能力
4. 排他性：redis保证一个事务诶的命令依次执行，不会被其他命令插入

### Redis 事务中的 WATCH 命令是什么？它的作用是什么？如何使用？

WATCH用于监视一个或多个键，当这些键的值在事务执行期间被其他客户端修改时，事务将被取消，以确保事务的原子性

### Redis 事务中的 MULTI/EXEC命令是什么？它的作用是什么？如何使用？

用于标记事务的开始，允许用户将一系列命令打包成一个原子操作，使用MULTI后，使用EXEC命令执行所有事务操作

### Redis 事务中如何实现乐观锁机制？

可以使用WATCH命令来实现乐观锁机制，监视一个或多个键，当这些键被其他客户端修改时，事务可以中止以避免冲突

## Redis PUB/SUB

是一种消息传递模式，允许发布者向多个订阅者发送消息，用于实现消息广播和实时通知

工作原理: 通过让订阅者订阅特定的频道来实现消息发布和传递，发布者将消息发送到频道，订阅者接收并处理消息

应用场景: 实时消息传递、事件通知、即时聊天等场景，其中多个订阅者可以接收来自发布者的消息通知

优缺点: 优点是实时性高，简单易用，但缺点是无法持久化消息和不支持复杂的消息路由

### 如何保证消息顺序性？

不能保证消息的严格顺序性，因为它是异步的，消息到达订阅者的顺序不一定与发布顺序相同

## 主从复制

### 什么是Redis主从复制？它的作用是什么？

主从复制通过将一个Redis服务器（主节点）的数据复制到其他Redis服务器（从节点），以实现数据的备份、扩展读取能力和提高系统可用性

### Redis主从复制的实现方式有哪些？它们有何不同？

同步复制（Sync Replication）和部分重同步（Partial Resynchronization）；主要区别在于复制开始的方式和数据传输的内容，同步复制需要全量传输数据，而部分重同步只传输从上次同步点之后的增量数据

### Redis主从复制的配置参数有哪些？如何进行配置？

配置参数包括slaveof、masterauth等，可通过配置文件或命令行来进行配置

###  Redis主从复制的延迟问题如何解决？

修改从几点参数配置；写外部监控程序监听主从节点的复制偏移量，当延迟较大时触发报警或者通知客户端避免读取延迟过高的从节点

### 如何实现Redis主从复制的高可用性？

可以用Redis Sentinel或Redis Cluster来自动故障转移和提供更好的高可用性

### Redis主从复制的安全性如何保证？有哪些措施可以使用？

配置密码（requirepass）、使用SSL/TLS进行加密通信、限制连接IP地址、并定期执行访问控制列表（ACL）等措施来保证

## 集群分片

Redis集群分片将数据分布在多个节点上，提高了数据处理能力和容量，并实现了高可用性，同时保持了Redis的简单性和性能

## 一致性哈希

### 什么是一致性哈希算法？它的作用是什么？

是一种分布式系统中的数据分片和负载均衡技术，用于将数据分布到多个节点，同时允许动态添加或删除节点而不影响大部分数据的映射关系

## Redis的线程模型



